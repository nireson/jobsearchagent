{% extends "base.html" %}

{% block title %}AOTT AI Research Agent - Run Task{% endblock %}

{% block content %}
<div class="row">
    <div class="col-lg-12">
        <div class="card mb-4">
            <div class="card-header">
                <h2><i class="fas fa-play-circle me-2"></i>Run Browser Task</h2>
            </div>
            <div class="card-body">
                <form id="taskForm">
                    <div class="mb-3">
                        <label for="promptInput" class="form-label">Enter your task instructions:</label>
                        <textarea class="form-control" id="promptInput" rows="4" placeholder="e.g., Go to example.com and search for 'climate change news'"></textarea>
                    </div>
                    
                    <div class="mb-3">
                        <label for="formatPrompt" class="form-label">
                            <i class="fas fa-file-alt me-1"></i> Output Document Format (optional):
                        </label>
                        <textarea class="form-control" id="formatPrompt" rows="3" placeholder="e.g., Format the output as a business report with executive summary, findings, and recommendations"></textarea>
                        <div class="form-text">Specify how you want the results to be formatted in the output document</div>
                    </div>
                    
                    <button type="submit" class="btn btn-primary" id="runButton">
                        <i class="fas fa-play me-2"></i>Run Task
                    </button>
                </form>
            </div>
        </div>

        <!-- Task Status and Controls -->
        <div class="card mb-4" id="taskStatus" style="display: none;">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h3><i class="fas fa-tasks me-2"></i>Task Status</h3>
                <div>
                    <button class="btn btn-danger" id="cancelButton">
                        <i class="fas fa-stop-circle me-2"></i>Cancel Task
                    </button>
                    <button class="btn btn-warning ms-2" id="endButton">
                        <i class="fas fa-flag-checkered me-2"></i>End Task
                    </button>
                    <button class="btn btn-warning ms-2" id="restartAppButton">
                        <i class="fas fa-sync-alt me-2"></i>Restart App
                    </button>
                </div>
            </div>
            <div class="card-body">
                <div class="task-info mb-3">
                    <p><strong>Task ID:</strong> <span id="taskId">-</span></p>
                    <p><strong>Started:</strong> <span id="taskStarted">-</span></p>
                    <p><strong>Status:</strong> <span id="taskStatusText" class="badge bg-info">Running</span></p>
                </div>
                <div class="progress mb-3" style="height: 25px;">
                    <div id="taskProgress" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- Task Logs -->
        <div class="card" id="logCard" style="display: none;">
            <div class="card-header">
                <h3><i class="fas fa-terminal me-2"></i>Task Logs</h3>
            </div>
            <div class="card-body">
                <div class="log-container">
                    <pre id="logOutput" class="log-output"></pre>
                </div>
            </div>
        </div>

        <!-- Task Result -->
        <div class="card mt-4" id="resultCard" style="display: none;">
            <div class="card-header">
                <h3><i class="fas fa-check-circle me-2"></i>Task Result</h3>
            </div>
            <div class="card-body">
                <div id="resultContent"></div>
                <div class="mt-3">
                    <a id="downloadLink" href="#" class="btn btn-success">
                        <i class="fas fa-file-word me-2"></i>Download Word Document
                    </a>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Current task information
    let currentTaskId = null;
    let taskStartTime = null;
    let logUpdateInterval = null;
    let taskRunning = false;
    let socket = null;

    // Initialize Socket.IO
    function initializeSocket() {
        // Disconnect existing socket if any
        if (socket) {
            // Remove all listeners to prevent duplicates
            socket.off('connect');
            socket.off('connect_error');
            socket.off('task_log');
            socket.off('task_complete');
            socket.off('task_error');
            socket.off('task_cancelled');
            socket.off('disconnect');
            socket.off('reconnect');
            
            // Disconnect the socket
            socket.disconnect();
        }

        socket = io({
            transports: ['websocket'],
            upgrade: false,
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000
        });
        
        // Handle socket events
        socket.on('connect', function() {
            console.log('Socket.IO connected');
            
            // If we have a current task, make sure we're subscribed to its events
            if (currentTaskId) {
                console.log(`Reattaching to task ${currentTaskId}`);
                addLogMessage('Connection to server established', false);
            } else {
                addLogMessage('Connected to server', false);
            }
        });

        socket.on('connect_error', function(error) {
            console.error('Socket.IO connection error:', error);
            addLogMessage('Error: Connection to server lost. Please refresh the page.');
        });
        
        socket.on('task_log', function(data) {
            console.log('Received task log:', data);
            if (data.task_id === currentTaskId) {
                addLogMessage(data.message);
                updateTaskProgress();
            }
        });
        
        socket.on('task_complete', function(data) {
            console.log('Task complete:', data);
            if (data.task_id === currentTaskId) {
                // Check if this is a regular completion or an ended task with partial results
                const status = data.status === 'ended' ? 'ended' : 'success';
                completeTask(status, data.result, data.filename);
            }
        });
        
        socket.on('task_error', function(data) {
            console.log('Task error:', data);
            if (data.task_id === currentTaskId) {
                completeTask('error', data.error);
            }
        });
        
        socket.on('task_cancelled', function(data) {
            console.log('Task cancelled:', data);
            if (data.task_id === currentTaskId) {
                completeTask('cancelled');
            }
        });

        socket.on('task_ending', function(data) {
            console.log('Task ending:', data);
            if (data.task_id === currentTaskId) {
                addLogMessage('Task is ending - preserving partial results...');
                document.getElementById('taskStatusText').textContent = 'Ending';
                document.getElementById('taskStatusText').className = 'badge bg-info';
            }
        });

        socket.on('app_restarted', function(data) {
            console.log('Application restarted:', data);
            addLogMessage('Application restarted successfully');
            
            // Reset the UI
            resetTaskUI();
            
            // Reinitialize the socket connection
            initializeSocket();
        });
        
        socket.on('app_restart_error', function(data) {
            console.log('Application restart error:', data);
            addLogMessage(`Error during application restart: ${data.message}`);
        });

        socket.on('disconnect', function() {
            console.log('Socket.IO disconnected');
            addLogMessage('Warning: Connection to server lost. Attempting to reconnect...');
        });

        socket.on('reconnect', function(attemptNumber) {
            console.log('Socket.IO reconnected after', attemptNumber, 'attempts');
            addLogMessage('Reconnected to server');
            
            // If we have an active task, check its status
            if (currentTaskId && taskRunning) {
                fetch(`/task_status?task_id=${currentTaskId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'running') {
                            // Task is still running, update logs
                            const logOutput = document.getElementById('logOutput');
                            logOutput.textContent = '';
                            data.logs.forEach(log => {
                                addLogMessage(log, false);
                            });
                            addLogMessage('Reconnected to running task', true);
                        } else {
                            // Task is no longer running, reset UI
                            resetTaskUI();
                            addLogMessage('The task is no longer running. Please start a new task.');
                        }
                    })
                    .catch(error => {
                        console.error('Error checking task status after reconnect:', error);
                    });
            }
        });
    }

    // Initialize socket when page loads
    initializeSocket();
    
    // Check for any running tasks when the page loads
    window.addEventListener('load', function() {
        checkForRunningTasks();
    });
    
    // Function to check for any running tasks
    function checkForRunningTasks() {
        fetch('/task_status')
            .then(response => response.json())
            .then(data => {
                if (data.has_active_tasks) {
                    const taskIds = Object.keys(data.active_tasks);
                    if (taskIds.length > 0) {
                        // Reconnect to the first active task
                        reconnectToTask(taskIds[0]);
                    }
                }
            })
            .catch(error => {
                console.error('Error checking for running tasks:', error);
            });
    }
    
    // Function to reconnect to an existing task
    function reconnectToTask(taskId) {
        fetch(`/task_status?task_id=${taskId}`)
            .then(response => response.json())
            .then(data => {
                if (data.status === 'running') {
                    // Set current task ID
                    currentTaskId = taskId;
                    taskStartTime = new Date(data.started_at * 1000);
                    taskRunning = true;
                    
                    // Update UI
                    document.getElementById('promptInput').value = data.prompt;
                    document.getElementById('formatPrompt').value = data.format_prompt;
                    document.getElementById('runButton').disabled = true;
                    
                    // Show task status and logs
                    document.getElementById('taskStatus').style.display = 'block';
                    document.getElementById('logCard').style.display = 'block';
                    
                    document.getElementById('taskId').textContent = taskId;
                    document.getElementById('taskStarted').textContent = taskStartTime.toLocaleTimeString();
                    document.getElementById('taskStatusText').textContent = 'Running';
                    document.getElementById('taskStatusText').className = 'badge bg-info';
                    
                    // Display the logs
                    const logOutput = document.getElementById('logOutput');
                    logOutput.textContent = '';
                    data.logs.forEach(log => {
                        addLogMessage(log, false);
                    });
                    
                    // Start task updates
                    startTaskUpdates();
                    
                    addLogMessage('Reconnected to running task', false);
                }
            })
            .catch(error => {
                console.error('Error reconnecting to task:', error);
            });
    }
    
    // Form submission
    document.getElementById('taskForm').addEventListener('submit', function(e) {
        e.preventDefault();
        
        if (taskRunning) {
            alert('A task is already running. Please wait or cancel it first.');
            return;
        }
        
        const prompt = document.getElementById('promptInput').value.trim();
        if (!prompt) {
            alert('Please enter a task instruction');
            return;
        }
        
        startTask(prompt);
    });
    
    // Cancel button
    document.getElementById('cancelButton').addEventListener('click', function() {
        if (currentTaskId && taskRunning) {
            cancelTask(currentTaskId);
        }
    });
    
    // End Task button
    document.getElementById('endButton').addEventListener('click', function() {
        if (currentTaskId && taskRunning) {
            endTask(currentTaskId);
        }
    });
    
    // Start a new task
    function startTask(prompt) {
        // Get format prompt if provided
        const formatPrompt = document.getElementById('formatPrompt').value.trim();
        
        // Reset UI
        document.getElementById('logOutput').textContent = '';
        document.getElementById('resultContent').textContent = '';
        document.getElementById('resultCard').style.display = 'none';
        document.getElementById('taskProgress').style.width = '0%';
        
        // Show task status and logs
        document.getElementById('taskStatus').style.display = 'block';
        document.getElementById('logCard').style.display = 'block';
        
        // Disable run button
        document.getElementById('runButton').disabled = true;
        
        // Send task request
        fetch('/run_task', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                prompt: prompt,
                formatPrompt: formatPrompt
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                currentTaskId = data.task_id;
                taskStartTime = new Date();
                taskRunning = true;
                
                // Update global task state
                if (window.taskManager) {
                    window.taskManager.setTaskRunning(currentTaskId, true);
                }
                
                // Update UI
                document.getElementById('taskId').textContent = data.task_id;
                document.getElementById('taskStarted').textContent = taskStartTime.toLocaleTimeString();
                document.getElementById('taskStatusText').textContent = 'Running';
                document.getElementById('taskStatusText').className = 'badge bg-info';
                
                // Add initial log message
                addLogMessage(`Task started: ${prompt}`);
                
                // Start task progress updates
                startTaskUpdates();
            } else {
                alert(`Error: ${data.message}`);
                document.getElementById('runButton').disabled = false;
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('An error occurred while starting the task');
            document.getElementById('runButton').disabled = false;
        });
    }
    
    // Cancel a running task
    function cancelTask(taskId) {
        if (!taskRunning) return;
        
        addLogMessage('Cancelling task...');
        
        fetch('/cancel_task', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                task_id: taskId
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                addLogMessage('Task cancellation requested. Waiting for process to terminate...');
                document.getElementById('taskStatusText').textContent = 'Cancelling';
                document.getElementById('taskStatusText').className = 'badge bg-warning';
            } else {
                addLogMessage(`Error cancelling task: ${data.message}`);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            addLogMessage('An error occurred while cancelling the task');
        });
    }
    
    // End a running task but preserve partial results
    function endTask(taskId) {
        if (!taskRunning) return;
        
        addLogMessage('Ending task and preserving partial results...');
        
        fetch('/end_task', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                task_id: taskId
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                addLogMessage('Task ending requested. Preserving current progress...');
                document.getElementById('taskStatusText').textContent = 'Ending';
                document.getElementById('taskStatusText').className = 'badge bg-info';
            } else {
                addLogMessage(`Error ending task: ${data.message}`);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            addLogMessage('An error occurred while ending the task');
        });
    }
    
    // Restart the app
    document.getElementById('restartAppButton').addEventListener('click', function() {
        if (confirm('Are you sure you want to restart the application? This will cancel any running tasks.')) {
            restartApp();
        }
    });
    
    function restartApp() {
        addLogMessage('Initiating application restart...');
        
        fetch('/restart_app', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                addLogMessage('Restart initiated. Please wait...');
                // The actual completion will be handled by the socket event
            } else {
                addLogMessage(`Error initiating restart: ${data.message}`);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            addLogMessage('An error occurred while requesting application restart');
        });
    }
    
    // Reset the task UI
    function resetTaskUI() {
        // Reset task variables
        currentTaskId = null;
        taskStartTime = null;
        taskRunning = false;
        
        // Stop task updates
        if (logUpdateInterval) {
            clearInterval(logUpdateInterval);
            logUpdateInterval = null;
        }
        
        // Re-enable run button
        document.getElementById('runButton').disabled = false;
        
        // Update task status
        document.getElementById('taskStatusText').textContent = 'Ready';
        document.getElementById('taskStatusText').className = 'badge bg-success';
        
        addLogMessage('Ready for new task');
    }
    
    // Complete a task
    function completeTask(status, result, filename) {
        // Update task status
        taskRunning = false;
        
        // Update global task state
        if (window.taskManager) {
            window.taskManager.setTaskRunning(null, false);
        }
        
        // Stop task updates
        if (logUpdateInterval) {
            clearInterval(logUpdateInterval);
            logUpdateInterval = null;
        }
        
        // Enable run button
        document.getElementById('runButton').disabled = false;
        
        // Update task status based on completion type
        if (status === 'success') {
            document.getElementById('taskStatusText').textContent = 'Completed';
            document.getElementById('taskStatusText').className = 'badge bg-success';
            document.getElementById('taskProgress').style.width = '100%';
            document.getElementById('taskProgress').className = 'progress-bar bg-success';
            
            // Display result
            document.getElementById('resultCard').style.display = 'block';
            document.getElementById('resultContent').innerHTML = `<pre>${result}</pre>`;
            
            // Set download link
            if (filename) {
                const downloadLink = document.getElementById('downloadLink');
                downloadLink.href = `/download_result/${filename}`;
                downloadLink.style.display = 'inline-block';
            }
            
            addLogMessage('Task completed successfully');
        } else if (status === 'error') {
            document.getElementById('taskStatusText').textContent = 'Error';
            document.getElementById('taskStatusText').className = 'badge bg-danger';
            document.getElementById('taskProgress').className = 'progress-bar bg-danger';
            
            // Display error message
            document.getElementById('resultCard').style.display = 'block';
            document.getElementById('resultContent').innerHTML = `<div class="alert alert-danger">${result}</div>`;
            
            addLogMessage(`Task failed: ${result}`);
        } else if (status === 'cancelled') {
            document.getElementById('taskStatusText').textContent = 'Cancelled';
            document.getElementById('taskStatusText').className = 'badge bg-secondary';
            document.getElementById('taskProgress').className = 'progress-bar bg-secondary';
            
            addLogMessage('Task was cancelled');
            
            // Reset the current task ID to allow starting a new task
            currentTaskId = null;
        } else if (status === 'ended') {
            document.getElementById('taskStatusText').textContent = 'Ended';
            document.getElementById('taskStatusText').className = 'badge bg-primary';
            document.getElementById('taskProgress').className = 'progress-bar bg-primary';
            
            // Display partial result
            document.getElementById('resultCard').style.display = 'block';
            document.getElementById('resultContent').innerHTML = `<pre>${result}</pre>`;
            
            // Set download link if available
            if (filename) {
                const downloadLink = document.getElementById('downloadLink');
                downloadLink.href = `/download_result/${filename}`;
                downloadLink.style.display = 'inline-block';
            }
            
            addLogMessage('Task was ended with partial results');
            
            // Reset the current task ID to allow starting a new task
            currentTaskId = null;
        }
    }
    
    // Add a message to the log
    function addLogMessage(message, autoScroll = true) {
        const logOutput = document.getElementById('logOutput');
        const timestamp = new Date().toLocaleTimeString();
        
        // Determine message type and apply appropriate styling
        let messageHtml = '';
        let messageClass = '';
        const timestampHtml = `<span class="timestamp">[${timestamp}]</span> `;
        
        // Check for agent thinking messages
        if (message.includes('ü§î Agent thinking:')) {
            messageClass = 'agent-thinking';
            message = message.replace('ü§î Agent thinking:', '');
            messageHtml = `${timestampHtml}<span class="${messageClass}">ü§î Agent thinking:</span> ${message}`;
        }
        // Check for agent action messages
        else if (message.includes('üîÑ Action:')) {
            messageClass = 'agent-action';
            message = message.replace('üîÑ Action:', '');
            messageHtml = `${timestampHtml}<span class="${messageClass}">üîÑ Action:</span> ${message}`;
        }
        // Check for agent observation messages
        else if (message.includes('üëÅÔ∏è Observation:')) {
            messageClass = 'agent-observation';
            message = message.replace('üëÅÔ∏è Observation:', '');
            messageHtml = `${timestampHtml}<span class="${messageClass}">üëÅÔ∏è Observation:</span> ${message}`;
        }
        // Check for error messages
        else if (message.includes('‚ùå Error:') || message.toLowerCase().includes('error:')) {
            messageClass = 'agent-error';
            messageHtml = `${timestampHtml}<span class="${messageClass}">${message}</span>`;
        }
        // Check for system messages
        else if (message.includes('SYSTEM MESSAGE:') || message.includes('Task ending requested')) {
            messageClass = 'system-message';
            messageHtml = `${timestampHtml}<span class="${messageClass}">${message}</span>`;
        }
        // Default formatting
        else {
            messageHtml = `${timestampHtml}${message}`;
        }
        
        // Add a new HTML element instead of using text
        const logEntry = document.createElement('div');
        logEntry.innerHTML = messageHtml;
        logOutput.appendChild(logEntry);
        
        // Auto-scroll to bottom
        if (autoScroll) {
            logOutput.scrollTop = logOutput.scrollHeight;
        }
    }
    
    // Update task progress
    function updateTaskProgress() {
        if (!taskStartTime || !taskRunning) return;
        
        const now = new Date();
        const elapsedSeconds = Math.floor((now - taskStartTime) / 1000);
        
        // Update progress bar (for visual feedback only)
        // We don't know actual progress, so we'll just use a slow-increasing progress
        // that never quite reaches 100% until complete
        const progressPercent = Math.min(95, Math.log(elapsedSeconds + 1) * 20);
        document.getElementById('taskProgress').style.width = `${progressPercent}%`;
    }
    
    // Start task progress updates
    function startTaskUpdates() {
        if (logUpdateInterval) {
            clearInterval(logUpdateInterval);
        }
        logUpdateInterval = setInterval(updateTaskProgress, 1000);
    }
</script>
{% endblock %}

{% extends "base.html" %}

{% block title %}AOTT AI Research Agent - Search{% endblock %}

{% block content %}
<div class="row">
    <div class="col-lg-12">
        <div class="card mb-4">
            <div class="card-header">
                <h2><i class="fas fa-search me-2"></i>Search Prompt</h2>
            </div>
            <div class="card-body">
                <h1 class="mb-4">Jobs Agent</h1>
                
                <!-- Agent Selection Toggle -->
                <div class="mb-3 agent-toggle-container d-flex align-items-center">
                    <label class="form-label me-2 mb-0">Agent Type:</label>
                    <label class="form-check-label me-2" for="agent-type-toggle">Browser Agent</label>
                    <div class="form-check form-switch form-check-inline me-2 mb-0">
                        <input class="form-check-input" type="checkbox" role="switch" id="agent-type-toggle" style="cursor: pointer;">
                    </div>
                    <label class="form-check-label" for="agent-type-toggle">Tavily Agent</label>
                </div>

                <form id="taskForm">
                    <!-- Model & Step Settings Row -->
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <label for="modelSelect" class="form-label">
                                <i class="fas fa-robot me-1"></i> Model:
                            </label>
                            <select class="form-select" id="modelSelect" name="modelSelect">
                                <!-- These will be populated dynamically with available models -->
                                <option value="" disabled>Loading models...</option>
                            </select>
                            <div class="form-text">Select the AI model to use for this search</div>
                        </div>
                        <div class="col-md-6">
                            <label for="outputFormatSelect" class="form-label">
                                <i class="fas fa-file-export me-1"></i> Output Format:
                            </label>
                            <select class="form-select" id="outputFormatSelect" name="outputFormatSelect">
                                <option value="docx" selected>Word Document (.docx)</option>
                                <option value="xlsx">Spreadsheet (.xlsx)</option>
                            </select>
                            <div class="form-text">Choose the format for the output file</div>
                        </div>
                    </div>
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <label for="maxSteps" class="form-label">
                                <i class="fas fa-shoe-prints me-1"></i> Maximum Steps:
                            </label>
                            <input type="number" class="form-control" id="maxSteps" name="maxSteps" min="5" max="100" value="30">
                            <div class="form-text">Limits how many browser actions the agent will perform overall</div>
                        </div>
                        <div class="col-md-6">
                            <div class="form-check mt-4 pt-2">
                                <input class="form-check-input" type="checkbox" id="runHeadlessCheckbox" name="runHeadlessCheckbox">
                                <label class="form-check-label" for="runHeadlessCheckbox">
                                    Run Headless (no visible browser window)
                                </label>
                                <div class="form-text">Check this to run the browser in the background.</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <label for="promptInput" class="form-label">Enter your search instructions:</label>
                        <textarea class="form-control" id="promptInput" rows="4" placeholder="e.g., Go to example.com and search for 'climate change news'"></textarea>
                    </div>
                    
                    <div class="mb-3">
                        <label for="formatPrompt" class="form-label">
                            <i class="fas fa-file-alt me-1"></i> Output Document Format Prompt (optional):
                        </label>
                        <textarea class="form-control" id="formatPrompt" rows="3" placeholder="e.g., Format the output as a business report with executive summary, findings, and recommendations"></textarea>
                        <div class="form-text">Specify how you want the results to be formatted in the output document</div>
                    </div>
                    
                    <button type="submit" class="btn btn-primary" id="runButton">
                        <i class="fas fa-search me-2"></i>Start Search
                    </button>
                </form>
            </div>
        </div>

        <!-- Task Status and Controls -->
        <div class="card mb-4" id="taskStatus" style="display: none;">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h3><i class="fas fa-tasks me-2"></i>Task Status</h3>
                <div>
                    <button class="btn btn-danger" id="cancelButton">
                        <i class="fas fa-stop-circle me-2"></i>Cancel Task
                    </button>
                    <button class="btn btn-warning ms-2" id="endButton">
                        <i class="fas fa-flag-checkered me-2"></i>End Task
                    </button>
                    <button class="btn btn-warning ms-2" id="restartAppButton">
                        <i class="fas fa-sync-alt me-2"></i>Restart App
                    </button>
                </div>
            </div>
            <div class="card-body">
                <div class="task-info mb-3">
                    <p><strong>Task ID:</strong> <span id="taskId">-</span></p>
                    <p><strong>Started:</strong> <span id="taskStarted">-</span></p>
                    <p><strong>Status:</strong> <span id="taskStatusText" class="badge bg-info">Running</span></p>
                </div>
                <div class="progress mb-3" style="height: 25px;">
                    <div id="taskProgress" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- Task Logs -->
        <div class="card" id="logCard" style="display: none;">
            <div class="card-header">
                <h3><i class="fas fa-terminal me-2"></i>Task Logs</h3>
            </div>
            <div class="card-body">
                <div class="log-container">
                    <pre id="logOutput" class="log-output"></pre>
                </div>
            </div>
        </div>

        <!-- Task Result -->
        <div class="card mt-4" id="resultCard" style="display: none;">
            <div class="card-header">
                <h3><i class="fas fa-check-circle me-2"></i>Task Result</h3>
            </div>
            <div class="card-body">
                <div id="resultContent"></div>
                <div class="mt-3">
                    <a id="downloadLink" href="#" class="btn btn-success">
                        <i class="fas fa-file-word me-2"></i>Download Word Document
                    </a>
                </div>
            </div>
        </div>
    </div>
</div>

{% endblock %}

{% block scripts %}
<script>
    // Current task information
    let currentTaskId = null;
    let taskStartTime = null;
    let logUpdateInterval = null;
    let taskRunning = false;
    let socket = null;
    
    // Load available models when page loads
    window.addEventListener('load', function() {
        loadAvailableModels();
        checkForRunningTasks();
    });
    
    // Function to load available models
    function loadAvailableModels() {
        const modelSelect = document.getElementById('modelSelect');
        modelSelect.innerHTML = '<option value="" disabled selected>Loading models...</option>';
        
        fetch('/available_models')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                modelSelect.innerHTML = ''; // Clear loading option
                
                if (data.error) {
                    console.error('Server reported error:', data.error);
                    // We'll still try to use the data if available
                }
                
                if (data.current_model) {
                    // Add current model as first option and select it
                    const currentOption = document.createElement('option');
                    currentOption.value = data.current_model.id;
                    currentOption.textContent = `${data.current_model.name} (Current)`;
                    currentOption.selected = true;
                    modelSelect.appendChild(currentOption);
                }
                
                // Add all available models
                if (data.available_models && data.available_models.length > 0) {
                    data.available_models.forEach(model => {
                        // Skip if this is the current model (already added)
                        if (data.current_model && model.id === data.current_model.id) {
                            return;
                        }
                        
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = model.name;
                        modelSelect.appendChild(option);
                    });
                } else {
                    // If no models available, show a default option
                    const defaultOption = document.createElement('option');
                    defaultOption.value = "";
                    defaultOption.textContent = "No models available";
                    defaultOption.disabled = true;
                    modelSelect.appendChild(defaultOption);
                }
            })
            .catch(error => {
                console.error('Error loading models:', error);
                
                // Clear previous options
                modelSelect.innerHTML = '';
                
                // Add default models
                const defaultModels = [
                    { id: "gpt-4o", name: "GPT-4o (Default)" },
                    { id: "claude-3-sonnet-20240229", name: "Claude 3 Sonnet (Default)" },
                    { id: "llama3", name: "Llama 3 (Default)" }
                ];
                
                // Add a current model option
                const currentOption = document.createElement('option');
                currentOption.value = defaultModels[0].id;
                currentOption.textContent = `${defaultModels[0].name}`;
                currentOption.selected = true;
                modelSelect.appendChild(currentOption);
                
                // Add the rest of the default models
                for (let i = 1; i < defaultModels.length; i++) {
                    const option = document.createElement('option');
                    option.value = defaultModels[i].id;
                    option.textContent = defaultModels[i].name;
                    modelSelect.appendChild(option);
                }
            });
    }

    // Initialize Socket.IO
    function initializeSocket() {
        // Disconnect existing socket if any
        if (socket) {
            // Remove all listeners to prevent duplicates
            socket.off('connect');
            socket.off('connect_error');
            socket.off('task_log');
            socket.off('task_complete');
            socket.off('task_error');
            socket.off('task_cancelled');
            socket.off('disconnect');
            socket.off('reconnect');
            
            // Disconnect the socket
            socket.disconnect();
        }

        socket = io({
            transports: ['websocket'],
            upgrade: false,
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000
        });
    
    // Handle socket events
    socket.on('connect', function() {
        console.log('Socket.IO connected');
            
            // If we have a current task, make sure we're subscribed to its events
            if (currentTaskId) {
                console.log(`Reattaching to task ${currentTaskId}`);
                addLogMessage('Connection to server established', false);
            } else {
                addLogMessage('Connected to server', false);
            }
        });

        socket.on('connect_error', function(error) {
            console.error('Socket.IO connection error:', error);
            addLogMessage('Error: Connection to server lost. Please refresh the page.');
    });
    
    socket.on('task_log', function(data) {
            console.log('Received task log:', data);
        if (data.task_id === currentTaskId) {
            addLogMessage(data.message);
            updateTaskProgress();
        }
    });
    
    socket.on('task_complete', function(data) {
            console.log('Task complete:', data);
        if (data.task_id === currentTaskId) {
                // Check if this is a regular completion or an ended task with partial results
                const status = data.status === 'ended' ? 'ended' : 'success';
                completeTask(status, data.result, data.filename);
        }
    });
    
    socket.on('task_error', function(data) {
            console.log('Task error:', data);
        if (data.task_id === currentTaskId) {
            completeTask('error', data.error);
        }
    });
    
    socket.on('task_cancelled', function(data) {
            console.log('Task cancelled event received:', data);
        if (data.task_id === currentTaskId) {
            addLogMessage(data.message || 'Task was cancelled.', false);
            resetTaskUI();
            document.getElementById('taskStatus').style.display = 'none';
            document.getElementById('logCard').style.display = 'none';
            document.getElementById('resultCard').style.display = 'none';
        }
    });

        socket.on('task_ending', function(data) {
            console.log('Task ending:', data);
            if (data.task_id === currentTaskId) {
                addLogMessage('Task is ending - preserving partial results...');
                document.getElementById('taskStatusText').textContent = 'Ending';
                document.getElementById('taskStatusText').className = 'badge bg-info';
            }
        });

        socket.on('app_restarted', function(data) {
            console.log('Application restarted:', data);
            addLogMessage('Application restarted successfully');
            
            // Reset the UI
            resetTaskUI();
            
            // Reinitialize the socket connection
            initializeSocket();
            
            // Reload models after restart
            loadAvailableModels();
        });
        
        socket.on('app_restart_error', function(data) {
            console.log('Application restart error:', data);
            addLogMessage(`Error during application restart: ${data.message}`);
        });

        socket.on('disconnect', function() {
            console.log('Socket.IO disconnected');
            addLogMessage('Warning: Connection to server lost. Attempting to reconnect...');
        });

        socket.on('reconnect', function(attemptNumber) {
            console.log('Socket.IO reconnected after', attemptNumber, 'attempts');
            addLogMessage('Reconnected to server');
            
            // If we have an active task, check its status
            if (currentTaskId && taskRunning) {
                fetch(`/task_status?task_id=${currentTaskId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'running') {
                            // Task is still running, update logs
                            const logOutput = document.getElementById('logOutput');
                            logOutput.textContent = '';
                            data.logs.forEach(log => {
                                addLogMessage(log, false);
                            });
                            addLogMessage('Reconnected to running task', true);
                        } else {
                            // Task is no longer running, reset UI
                            resetTaskUI();
                            addLogMessage('The task is no longer running. Please start a new task.');
                        }
                    })
                    .catch(error => {
                        console.error('Error checking task status after reconnect:', error);
                    });
            }
        });
    }

    // Initialize socket when page loads
    initializeSocket();
    
    // Function to check for any running tasks
    function checkForRunningTasks() {
        fetch('/task_status')
            .then(response => response.json())
            .then(data => {
                if (data.has_active_tasks) {
                    const taskIds = Object.keys(data.active_tasks);
                    if (taskIds.length > 0) {
                        // Reconnect to the first active task
                        reconnectToTask(taskIds[0]);
                    }
                }
            })
            .catch(error => {
                console.error('Error checking for running tasks:', error);
            });
    }
    
    // Function to reconnect to an existing task
    function reconnectToTask(taskId) {
        fetch(`/task_status?task_id=${taskId}`)
            .then(response => response.json())
            .then(data => {
                if (data.status === 'running') {
                    // Set current task ID
                    currentTaskId = taskId;
                    taskStartTime = new Date(data.started_at * 1000);
                    taskRunning = true;
                    
                    // Update UI
                    document.getElementById('promptInput').value = data.prompt;
                    document.getElementById('formatPrompt').value = data.format_prompt;
                    document.getElementById('runButton').disabled = true;
                    
                    // Show task status and logs
                    document.getElementById('taskStatus').style.display = 'block';
                    document.getElementById('logCard').style.display = 'block';
                    
                    document.getElementById('taskId').textContent = taskId;
                    document.getElementById('taskStarted').textContent = taskStartTime.toLocaleTimeString();
                    document.getElementById('taskStatusText').textContent = 'Running';
                    document.getElementById('taskStatusText').className = 'badge bg-info';
                    
                    // Display the logs
                    const logOutput = document.getElementById('logOutput');
                    logOutput.textContent = '';
                    data.logs.forEach(log => {
                        addLogMessage(log, false);
                    });
                    
                    // Start task updates
                    startTaskUpdates();
                    
                    addLogMessage('Reconnected to running task', false);
                }
            })
            .catch(error => {
                console.error('Error reconnecting to task:', error);
            });
    }
    
    // Form submission
    document.getElementById('taskForm').addEventListener('submit', function(e) {
        e.preventDefault();
        
        const promptInput = document.getElementById('promptInput').value.trim();
        const formatPrompt = document.getElementById('formatPrompt').value.trim();
        const modelSelect = document.getElementById('modelSelect').value;
        const maxSteps = document.getElementById('maxSteps').value;
        const runHeadless = document.getElementById('runHeadlessCheckbox').checked;
        
        // Get selected output format
        const outputFormatSelect = document.getElementById('outputFormatSelect');
        const outputFormat = outputFormatSelect ? outputFormatSelect.value : 'docx'; // Default to docx
        
        if (!promptInput) {
            alert('Please enter a search prompt');
            return;
        }
        
        // --- Prepare UI for New Task --- 
        document.getElementById('taskStatus').style.display = 'block'; // Show status section
        document.getElementById('logCard').style.display = 'block';    // Show log section
        document.getElementById('resultCard').style.display = 'none';  // Hide previous result
        
        // Disable form
        document.getElementById('promptInput').disabled = true;
        document.getElementById('formatPrompt').disabled = true;
        document.getElementById('modelSelect').disabled = true;
        document.getElementById('maxSteps').disabled = true;
        document.getElementById('runHeadlessCheckbox').disabled = true;
        document.getElementById('runButton').disabled = true; // Disable Run button
        document.getElementById('cancelButton').disabled = false; // ENABLE Cancel button
        document.getElementById('endButton').disabled = false;    // ENABLE End button
        
        // Clear previous logs
        document.getElementById('logOutput').textContent = '';
        
        // Reset progress bar and status text
        document.getElementById('taskProgress').style.width = '0%';
        document.getElementById('taskProgress').className = 'progress-bar progress-bar-striped progress-bar-animated bg-info'; // Reset style
        document.getElementById('taskStatusText').textContent = 'Starting...';
        document.getElementById('taskStatusText').className = 'badge bg-info';
        
        // Show global task indicator
        document.getElementById('taskIndicator').style.display = 'block';
        
        // Determine Agent Type from toggle
        const agentToggleInput = document.getElementById('agent-type-toggle');
        const agentType = agentToggleInput && agentToggleInput.checked ? 'tavily' : 'browser';
        
        const payload = {
            prompt: promptInput,
            formatPrompt: formatPrompt,
            model: modelSelect,
            maxSteps: maxSteps,
            agentType: agentType,
            outputFormat: outputFormat,
            runHeadless: runHeadless
        };
        console.log("[DEBUG index.html] Sending payload:", payload); // Log payload just before fetch
        
        // Send task to backend
        fetch('/run_task', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                // Store the task ID
                currentTaskId = data.task_id;
                
                // Store start time
                taskStartTime = new Date();
                
                // Mark task as running
                taskRunning = true;
                
                // Update task info
                document.getElementById('taskId').textContent = currentTaskId;
                document.getElementById('taskStarted').textContent = taskStartTime.toLocaleTimeString();
                document.getElementById('taskStatusText').textContent = 'Running'; // Update status to Running
                document.getElementById('taskStatusText').className = 'badge bg-primary'; // Update class
                
                // Add initial log message
                addLogMessage(`Task started with ID: ${currentTaskId}`);
                
                // Start periodic updates for elapsed time
                startTaskUpdates();
            } else {
                completeTask('error', data.message);
            }
        })
        .catch(error => {
            console.error('Error starting task:', error);
            completeTask('error', 'Failed to start task: ' + error.message);
        });
    });
    
    // Cancel button
    document.getElementById('cancelButton').addEventListener('click', function() {
        if (currentTaskId && taskRunning) {
            fetch('/cancel_task', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    task_id: currentTaskId
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    addLogMessage('Cancel request sent to backend.');
                    document.getElementById('taskStatusText').textContent = 'Cancelling';
                    document.getElementById('taskStatusText').className = 'badge bg-warning';
                } else {
                    addLogMessage(`Error sending cancel request: ${data.message}`);
                }
            })
            .catch(error => {
                console.error('Error sending cancel request:', error);
                addLogMessage('An error occurred while sending the cancel request');
            });
        }
    });
    
    // End Task button
    document.getElementById('endButton').addEventListener('click', function() {
        if (currentTaskId && taskRunning) {
            endTask(currentTaskId);
        }
    });
    
    // Start a new task
    function startTask(prompt) {
        // Get format prompt if provided
        const formatPrompt = document.getElementById('formatPrompt').value.trim();
        
        // Reset UI
        document.getElementById('logOutput').textContent = '';
        document.getElementById('resultContent').textContent = '';
        document.getElementById('resultCard').style.display = 'none';
        document.getElementById('taskProgress').style.width = '0%';
        
        // Show task status and logs
        document.getElementById('taskStatus').style.display = 'block';
        document.getElementById('logCard').style.display = 'block';
        
        // Disable run button
        document.getElementById('runButton').disabled = true;
        
        // Send task request
        fetch('/run_task', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                prompt: prompt,
                formatPrompt: formatPrompt
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                currentTaskId = data.task_id;
                taskStartTime = new Date();
                taskRunning = true;
                
                // Update global task state
                if (window.taskManager) {
                    window.taskManager.setTaskRunning(currentTaskId, true);
                }
                
                // Update UI
                document.getElementById('taskId').textContent = data.task_id;
                document.getElementById('taskStarted').textContent = taskStartTime.toLocaleTimeString();
                document.getElementById('taskStatusText').textContent = 'Running';
                document.getElementById('taskStatusText').className = 'badge bg-info';
                
                // Add initial log message
                addLogMessage(`Task started: ${prompt}`);
                
                // Start task progress updates
                startTaskUpdates();
            } else {
                alert(`Error: ${data.message}`);
                document.getElementById('runButton').disabled = false;
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('An error occurred while starting the task');
            document.getElementById('runButton').disabled = false;
        });
    }
    
    // Cancel a running task
    function cancelTask(taskId) {
        if (!taskRunning) return;
        
        addLogMessage('Cancelling task...');
        
        fetch('/cancel_task', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                task_id: taskId
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                addLogMessage('Task cancellation requested. Waiting for process to terminate...');
                document.getElementById('taskStatusText').textContent = 'Cancelling';
                document.getElementById('taskStatusText').className = 'badge bg-warning';
            } else {
                addLogMessage(`Error cancelling task: ${data.message}`);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            addLogMessage('An error occurred while cancelling the task');
        });
    }
    
    // End a running task but preserve partial results
    function endTask(taskId) {
        if (!taskRunning) return;
        
        addLogMessage('Ending task and preserving partial results...');
        
        fetch('/end_task', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                task_id: taskId
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                addLogMessage('Task ending requested. Preserving current progress...');
                document.getElementById('taskStatusText').textContent = 'Ending';
                document.getElementById('taskStatusText').className = 'badge bg-info';
            } else {
                addLogMessage(`Error ending task: ${data.message}`);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            addLogMessage('An error occurred while ending the task');
        });
    }
    
    // Restart the app
    document.getElementById('restartAppButton').addEventListener('click', function() {
        if (confirm('Are you sure you want to restart the application? This will cancel any running tasks.')) {
            restartApp();
        }
    });
    
    function restartApp() {
        addLogMessage('Initiating application restart...');
        
        fetch('/restart_app', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                addLogMessage('Restart initiated. Please wait...');
                // The actual completion will be handled by the socket event
            } else {
                addLogMessage(`Error initiating restart: ${data.message}`);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            addLogMessage('An error occurred while requesting application restart');
        });
    }
    
    // Reset the task UI
    function resetTaskUI() {
        currentTaskId = null;
        taskStartTime = null;
        taskRunning = false;
        
        // Stop task updates timer
        if (logUpdateInterval) {
            clearInterval(logUpdateInterval);
            logUpdateInterval = null;
        }
        
        // Re-enable form elements
        document.getElementById('runButton').disabled = false;
        document.getElementById('promptInput').disabled = false;
        document.getElementById('formatPrompt').disabled = false;
        document.getElementById('modelSelect').disabled = false;
        document.getElementById('maxSteps').disabled = false;
        document.getElementById('runHeadlessCheckbox').disabled = false;
        document.getElementById('outputFormatSelect').disabled = false; // Re-enable output format
        
        // Ensure Cancel/End buttons are disabled (as task is over)
        document.getElementById('cancelButton').disabled = true; 
        document.getElementById('endButton').disabled = true;
        
        // Hide the global task indicator in the sidebar
        if (typeof updateTaskIndicator === 'function') { // Check if function exists (it's in main.js)
            updateTaskIndicator(false);
        } 
        // Note: We don't hide the status/log/result sections here anymore
        // Note: We don't clear logs/results here; they show the final state
        // Note: We don't add 'Ready for new task' log here; completion messages handle that
    }
    
    // Complete a task
    function completeTask(status, result, filename) {
        // Update task status
        taskRunning = false;
        
        // Update global task state
        if (window.taskManager) {
            window.taskManager.setTaskRunning(null, false);
        }
        
        // Stop task updates
        if (logUpdateInterval) {
            clearInterval(logUpdateInterval);
            logUpdateInterval = null;
        }
        
        // Enable run button and other form elements
        document.getElementById('runButton').disabled = false;
        document.getElementById('promptInput').disabled = false;
        document.getElementById('formatPrompt').disabled = false;
        document.getElementById('modelSelect').disabled = false;
        document.getElementById('maxSteps').disabled = false;
        document.getElementById('runHeadlessCheckbox').disabled = false;
        document.getElementById('outputFormatSelect').disabled = false;
        document.getElementById('cancelButton').disabled = true; // Disable cancel/end buttons
        document.getElementById('endButton').disabled = true;
        
        // Update task status based on completion type
        if (status === 'success' || status === 'completed') { // Combine success/completed
            document.getElementById('taskStatusText').textContent = 'Completed';
            document.getElementById('taskStatusText').className = 'badge bg-success';
            document.getElementById('taskProgress').style.width = '100%';
            document.getElementById('taskProgress').className = 'progress-bar bg-success';
            
            // Display result
            document.getElementById('resultCard').style.display = 'block';
            document.getElementById('resultContent').innerHTML = `<pre>${result}</pre>`;
            
            // Set download link
            if (filename) {
                const downloadLink = document.getElementById('downloadLink');
                downloadLink.href = `/download_result/${filename}`;
                downloadLink.style.display = 'inline-block';
            }
            
            addLogMessage('Task completed successfully');
        } else if (status === 'error') {
            document.getElementById('taskStatusText').textContent = 'Error';
            document.getElementById('taskStatusText').className = 'badge bg-danger';
            document.getElementById('taskProgress').className = 'progress-bar bg-danger';
            document.getElementById('taskProgress').style.width = '100%'; // Fill bar on error
            
            // Display error message
            document.getElementById('resultCard').style.display = 'block';
            document.getElementById('resultContent').innerHTML = `<div class="alert alert-danger">${result}</div>`;
            
            addLogMessage(`Task failed: ${result}`);
        } else if (status === 'ended') {
            document.getElementById('taskStatusText').textContent = 'Ended';
            document.getElementById('taskStatusText').className = 'badge bg-primary';
            document.getElementById('taskProgress').className = 'progress-bar bg-primary';
            document.getElementById('taskProgress').style.width = '100%'; // Fill bar on ended
            
            // Display partial result
            document.getElementById('resultCard').style.display = 'block';
            document.getElementById('resultContent').innerHTML = `<pre>${result}</pre>`;
            
            // Set download link if available
            if (filename) {
                const downloadLink = document.getElementById('downloadLink');
                downloadLink.href = `/download_result/${filename}`;
                downloadLink.style.display = 'inline-block';
            }
            
            addLogMessage('Task was ended with partial results');
        }
        
        // --- Common actions after any completion status --- 
        resetTaskUI(); // Re-enable form, disable cancel/end, hide sidebar indicator
    }
    
    // Add a message to the log
    function addLogMessage(message, autoScroll = true) {
        const logOutput = document.getElementById('logOutput');
        const timestamp = new Date().toLocaleTimeString();
        
        // Determine message type and apply appropriate styling
        let messageHtml = '';
        let messageClass = '';
        const timestampHtml = `<span class="timestamp">[${timestamp}]</span> `;
        
        // Check for agent thinking messages
        if (message.includes('🤔 Agent thinking:')) {
            messageClass = 'agent-thinking';
            message = message.replace('🤔 Agent thinking:', '');
            messageHtml = `${timestampHtml}<span class="${messageClass}">🤔 Agent thinking:</span> ${message}`;
        }
        // Check for agent action messages
        else if (message.includes('🔄 Action:')) {
            messageClass = 'agent-action';
            message = message.replace('🔄 Action:', '');
            messageHtml = `${timestampHtml}<span class="${messageClass}">🔄 Action:</span> ${message}`;
        }
        // Check for agent observation messages
        else if (message.includes('👁️ Observation:')) {
            messageClass = 'agent-observation';
            message = message.replace('👁️ Observation:', '');
            messageHtml = `${timestampHtml}<span class="${messageClass}">👁️ Observation:</span> ${message}`;
        }
        // Check for error messages
        else if (message.includes('❌ Error:') || message.toLowerCase().includes('error:')) {
            messageClass = 'agent-error';
            messageHtml = `${timestampHtml}<span class="${messageClass}">${message}</span>`;
        }
        // Check for system messages
        else if (message.includes('SYSTEM MESSAGE:') || message.includes('Task ending requested')) {
            messageClass = 'system-message';
            messageHtml = `${timestampHtml}<span class="${messageClass}">${message}</span>`;
        }
        // Default formatting
        else {
            messageHtml = `${timestampHtml}${message}`;
        }
        
        // Add a new HTML element instead of using text
        const logEntry = document.createElement('div');
        logEntry.innerHTML = messageHtml;
        logOutput.appendChild(logEntry);
        
        // Auto-scroll to bottom
        if (autoScroll) {
        logOutput.scrollTop = logOutput.scrollHeight;
        }
    }
    
    // Update task progress
    function updateTaskProgress() {
        if (!taskStartTime || !taskRunning) return;
        
        const now = new Date();
        const elapsedSeconds = Math.floor((now - taskStartTime) / 1000);
        
        // Update progress bar (for visual feedback only)
        // We don't know actual progress, so we'll just use a slow-increasing progress
        // that never quite reaches 100% until complete
        const progressPercent = Math.min(95, Math.log(elapsedSeconds + 1) * 20);
        document.getElementById('taskProgress').style.width = `${progressPercent}%`;
    }
    
    // Start task progress updates
    function startTaskUpdates() {
        if (logUpdateInterval) {
            clearInterval(logUpdateInterval);
        }
        logUpdateInterval = setInterval(updateTaskProgress, 1000);
    }
</script>
{% endblock %}